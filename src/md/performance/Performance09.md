---
title: "09 案例分析：池化对象的应用场景"
index: true
icon: chart-simple
---

像线程资源、数据库连接资源或者TCP连接等，这类对象的初始化通常需要花费较长时间，如果频繁的创建和销毁，就会耗费大量的系统资源，造成不必要的性能
损失。

并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以**使用一个虚拟的池子，将这些资源保存起来，
当使用的时候，我们就从池子里快速获取一个即可。**

## 公用池化包Commons Pool 2.0

### Jedis JMH测试

```java

@Fork(2)
@State(Scope.Benchmark)
@Warmup(iterations = 5, time = 1)
@Measurement(iterations = 5, time = 1)
@BenchmarkMode(Mode.Throughput)
public class JedisPoolVSJedisBenchmark {
    JedisPool pool = new JedisPool("localhost", 6379);

    @Benchmark
    public void testPool() {
        Jedis jedis = pool.getResource();
        jedis.set("a", UUID.randomUUID().toString());
        jedis.close();
    }

    @Benchmark
    public void testJedis() {
        Jedis jedis = new Jedis("localhost", 6379);
        jedis.set("a", UUID.randomUUID().toString());
        jedis.close();
    }
    //...
}
```

使用了连接池的方式，它的吞吐量是未使用连接池方式的 5 倍！

## 数据库连接池HikariCP

HikariCP 源于日语“光”的意思（和光速一样快），它是 SpringBoot 中默认的数据库连接池。数据库是我们工作中经常使用到的组件，针对数据库设计的客
户端连接池是非常多的，它的设计原理与我们在本课时开头提到的基本一致，可以有效地减少数据库连接创建、销毁的资源消耗。

**HikariCP 为什么快呢？主要有三个方面：**

- 它使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作；
- 优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令；
- 实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争。

数据库连接池同样面临一个最大值（maximumPoolSize）和最小值（minimumIdle）的问题。这里同样有一个非常高频的面试题：你平常会把连接池设置成多大呢？

根据经验，数据库连接，只需要 20~50 个就够用了。具体的大小，要根据业务属性进行调整，但大得离谱肯定是不合适的。

另外，根据数据库查询和事务类型，一个应用中是可以配置多个数据库连接池的，这个优化技巧很少有人知道，在此简要描述一下。

业务类型通常有两种：一种需要快速的响应时间，把数据尽快返回给用户；另外一种是可以在后台慢慢执行，耗时比较长，对时效性要求不高。如果这两种业务
类型，共用一个数据库连接池，就容易发生资源争抢，进而影响接口响应速度。虽然微服务能够解决这种情况，但大多数服务是没有这种条件的，这时就可以对
连接池进行拆分。

如图，在同一个业务中，根据业务的属性，我们分了两个连接池，就是来处理这种情况的。

## 结果缓存池

到了这里你可能会发现池（Pool）与缓存（Cache）有许多相似之处。

它们之间的一个共同点，就是将对象加工后，存储在相对高速的区域。我习惯性将**缓存**看作是**数据对象**，而把**池中的对象**看作是
**执行对象**。
缓存中的数据有一个命中率问题，而池中的对象一般都是对等的。

考虑下面一个场景，jsp 提供了网页的动态功能，它可以在执行后，编译成 class 文件，加快执行速度；再或者，一些媒体平台，会将热门文章，定时转化成
静态的 html 页面，仅靠 nginx 的负载均衡即可应对高并发请求（动静分离）。

这些时候，你很难说清楚，这是针对缓存的优化，还是针对对象进行了池化，它们在本质上只是保存了某个执行步骤的结果，使得下次访问时不需要从头再来。
我通常把这种技术叫作结果缓存池（Result Cache Pool），属于多种优化手段的综合。

这些时候，你很难说清楚，这是针对缓存的优化，还是针对对象进行了池化，它们在本质上只是保存了某个执行步骤的结果，使得下次访问时不需要从头再来。
我通常把这种技术叫作结果缓存池（Result Cache Pool），属于多种优化手段的综合。

## 小结

总体来说，当你遇到下面的场景，就可以考虑使用池化来增加系统性能：

- 对象的创建或者销毁，需要耗费较多的系统资源；
- 对象的创建或者销毁，耗时长，需要繁杂的操作和较长时间的等待；
- 对象创建后，通过一些状态重置，可被反复使用。